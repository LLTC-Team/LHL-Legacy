# LVM 虚拟机内存描述

本文档将会描述LVM虚拟机内部的内存布局

<!-- TOC -->

- [LVM 虚拟机内存描述](#lvm)
  - [约定](#)
  - [内存管理器](#)
  - [运行时内存区域](#)
    - [代码区](#)
    - [栈区](#)
      - [概览](#)
      - [栈帧](#)
        - [栈帧结构](#)
        - [栈帧内存数据查找](#)
        - [栈帧的创建](#)
        - [栈帧的销毁](#)
    - [堆区](#)
      - [存储管理器](#)

<!-- /TOC -->

## 约定

- 以下所说的所有`指针`都代表一个逻辑上的内存地址，而不是C\C++语言中的指针。`指针`都以64位整数储存，以寻址更大的内存空间。
- 以下的所有数据结构只是逻辑上的数据结构，并不限制底层实现方式，只要使其满足本文档所规定的所有功能即可。
- 本文档的实例代码与字节码仅用作示例，实际结果可能会有所出入。
- 本文档中提到的虚拟机指令将会在其他文档中详细描述。

## 内存管理器

内存管理器将会管理LVM中的所有内存，它将会根据需求动态地分配、申请和释放内存。不同的内存区域将会使用不同的内存管理器。

内存管理器应该使用分页的方式组合内存。每一内存页大小都应是确定的，并且需要对4字节对齐。默认的内存页大小为1048576字节(`0x00000`-`0xFFFFF`)，也就是1MB。

内存管理器应该对逻辑内存位置进行相应的处理和映射。在外部看来，内存管理器就是一个很大的字节数组，数组下标是一个64位整数。其他操作对外部隐藏。

内存管理器是LVM的核心，内存管理器中出现的异常（如主机内存）通常会直接导致LVM崩溃退出。

## 运行时内存区域

LVM将会将虚拟机占有的内存分为3个区域：代码区，栈区和堆区。

虚拟机所有的数据都应以4个字节为单位进行存取，或者说寄存器的大小为4字节。也就是说长整数、浮点数与引用将会占用两个寄存器位置。

### 代码区

顾名思义，代码区将会存储从原文件读取的所有字节码指令。

### 栈区

#### 概览

栈区中维护一个函数调用栈，栈中的元素是函数调用栈帧（以下简称栈帧）。栈的功能是维护函数调用链，调度函数调用，处理函数参数及其返回值等。栈区内存是动态的，栈帧将会随函数调用而被创建，随函数返回而销毁。先调用的函数的栈帧靠近栈底，后调用的函数靠近栈顶。

栈对高层代码和编译器是不可见的，栈只能由LVM直接操作。编译器只能通过以下方式指导LVM对栈的操作：

1. 提供栈帧及其内部结构的大小
2. 以字节码指令的方式调用函数
3. 读写临时变量，参数或返回值

这里的栈只是逻辑上的栈，并不要求在实际实现中使用诸如`stack<StackFrame>`的数据结构实现。下面可以看到，栈帧结构的设计最大程度上使栈区的内存紧凑，也意味着仅使用一个数组也可以完整的实现完整的栈区功能。

栈区维护两个指针：`top`和`top_sp`。它们将会指明当前活动栈帧的临时变量区。

#### 栈帧

栈帧又称函数活动记录。在编译时，所有函数的栈帧大小都是可以确定的，LVM会根据字节码中的描述的大小和其他信息创建栈帧并初始化某些信息以供函数正确运行。如果出现某些问题以至于无法创建栈帧（比如主机内存耗尽），LVM将会在通知用户后退出运行。

##### 栈帧结构

这里描述内存区域中，编号越小越靠近栈顶。

1. **临时变量区** 临时变量区将会存储函数运行时所创建的临时变量。该区域的大小由函数代码决定。
2. **局部数据区** 局部数据区会存放LVM运行时需要存储的某些辅助数据：

   数据名称 | 描述 | 储存类型
   ----|------|--------
   ac | 实际参数个数 | int
   as | 实际参数大小 | int
   rs | 返回值大小   | int
   fs | 当前栈帧大小 | int
   pc | 当前运行的字节码编号 | int

3. **访问链区** 访问链区将会存储**显示表**中上一个与此函数嵌套深度相同函数调用栈的指针，称为访问链。访问链与显示表的详细操作将会在下面的文档进行说明。

   数据名称 | 描述 | 储存类型
   ----|------|--------
   al | 访问链指针* | long

4. **控制链区** 控制链将会存储此函数调用者的相关信息，以支持函数返回时恢复调用者的状态。控制链区应存储指向调用者的函数栈帧的指针和返回位置等信息。

   数据名称 | 描述 | 储存类型
   ----|------|--------
   rf | 调用者栈帧指针* | long
   rp | 调用者下一个字节码编号 | int

5. **返回值区** 返回值区是根据函数返回值类型所预留的存储返回值的区域。该区域的大小由函数返回值类型决定。
6. **实际参数区** 实际参数区会存储函数调用所需要的所有实际参数。该区域的大小由函数代码决定。

_* 这两种指针都指向对应栈帧在活动时的`top_sp`位置_

注意：目前LVM仅支持栈帧最多寻址到255个寄存器，也就是0-FF。但实际上，某些位置将会作为逻辑位置以支持其他功能。

目前用作逻辑位置的寄存器有：

- `FF`：表示访问链。用于支持嵌套函数作用域定位。虚拟机读到FF位置时，应该继续向后读取以进一步确定嵌套深度和对应位置。
- `FA`-`FB`：这两个位置用于定位上一次函数调用产生的返回值。
- `FC`-`FE`：这些位置留作以后扩展。

可以看到，尽管它们的占用了最后几个编号，但是它们仍然处于整个栈帧的中间位置，甚至不属于此栈帧。实际可储存变量的寄存器有250个,位置是`0`-`F9`。

##### 栈帧内存数据查找

- 被调用者的实际参数区紧邻调用者的栈帧，这样调用者无需创建整个栈帧就可以填入参数。
- 调用者知道实际参数的大小，所以即使栈顶指针已经回退，调用者也可以知道返回值的位置并进行访问，对于参数可变的函数也是如此。
- 字节码指令会根据寄存器的编号进行数据读取。寄存器编号从`0`开始。开始的某些寄存器存储函数参数，函数内部的局部变量存储在参数之后。它们的寄存器的编号是连续的，但是参数和局部变量的实际内存位置是不连续的。参数占用的寄存器数量可以存储在临时变量区。

  >例1：对于以下代码
  >
  >```clojure
  >(defn fun [arg1 arg2 arg3]
  >    (def a (+ arg1 arg2))
  >    (def b (* arg2 arg3))
  >    (def c (- a b))
  >)
  >```
  >
  >的字节码指令为：
  >
  >```
  >; 这是注释
  >function #1 int fun (int,int,int)
  >0  iadd 3 0 1
  >1  imul 4 2 3
  >2  isub 5 3 4
  >3  ireturn 5   ; 以最后一个表达式的值为返回值
  >; 指令首字母‘i’表示操作数都为int类型\
  >; 寄存器布局：
  >; 0 -> arg1   -\
  >; 1 -> arg2    |-->实际参数区
  >; 2 -> arg3   -/
  >; 3 -> a      -\
  >; 4 -> b       |-->临时变量区
  >; 5 -> c      -/
  >```
- 对于嵌套在其他函数中的函数，如果它想访问上层函数的局部变量或是实际参数，就与要使用显示表和访问链进行访问。

  >例2：以下代码
  >
  >```clojure
  >(defn func1 [arg]
  >    (defn func2 [] (+ arg arg))
  >    (func2)
  >)
  >```
  >
  >的字节码指令为：
  >
  >```
  >function #1 int func1 (int) ; np(嵌套深度) = 1
  >0  invoke #2
  >1  ireturn FA  ; 返回func2的返回值
  >
  >function #2 int func2 (void) ; np = 2
  >0  iadd 0 FF#1$0 FF#1$0
  >1  ireturn 0
  >
  >; FF#1$0 表示目前函数调用栈中最靠近栈顶的、嵌套深度为1的栈帧中编号为0的寄存器位置。
  >; 支持查找该栈帧的数据结构是堆中的显示表，它的维护依靠栈帧中的访问链。
  >; 关于显示表的更多信息，将会在堆中的文档中详细说明。
  >```
- 下面说明如何根据`top_sp`指针访问所有数据。约定`stack_mm`为栈的内存管理器，相应的函数的功能由其名称表述。这里只是实例代码，主要目的是为了表示数据的相对位置。
   ```c++
   //控制链区
   int32_t rp = stack_mm.readInt(top_sp - 1);
   int64_t rf = stack_mm.readLong(top_sp - 3);
   //访问链区
   int64_t al = stack_mm.readLong(top_sp - 5);
   //局部数据区
   int32_t pc = stack_mm.readInt(top_sp - 6);
   int32_t fs = stack_mm.readInt(top_sp - 7);
   int32_t rs = stack_mm.readInt(top_sp - 8)
   int32_t as = stack_mm.readInt(top_sp - 9);
   int32_t ac = stack_mm.readInt(top_sp - 10);

   //函数参数读取
   int64_t argumentArea = top_sp - 10 - rs - as;
   //参数区起始位置
   int32_t a1 = stack_mm.read<Type>(argumentArea + n);
   //<Type>为参数类型。n为寄存器的编号

   //临时变量读取
   int32_t t1 = stack_mm.read<Type>(top_sp + m);
   //<Type>为参数类型。m为寄存器的编号
   ```

##### 栈帧的创建

栈帧创建由`invoke`指令触发。主函数的栈帧由LVM自行创建。

栈帧的创建由调用代码序列负责，它应该会进行以下操作：

1. 计算实际参数的值，并拷贝到被调用者的实际参数区中
2. 设置被调用者的控制链，设置`top`和`top_sp`指针，将原来的`top_sp`指针储存到控制链中
3. 将显示表中对应的嵌套深度的指针存到栈帧的访问链中，并使显示表的那个位置指向这个栈帧
4. 初始化其他状态信息
5. 开始执行函数代码

##### 栈帧的销毁

栈帧销毁由`return` `ireturn` `freturn` `rreturn`指令触发。或者函数异常退出，也会导致栈帧的销毁。

栈帧的销毁由返回代码序列负责，它应该会进行以下操作：

1. 将返回值放入对应的返回值区域
2. 根据控制链将状态恢复到调用者，恢复`top`和`top_sp`指针，跳转到返回地址
3. 即使`top_sp`已经减少，但是因为调用者知道所有参数的大小，所以调用者可以访问被调用函数的返回值

### 堆区

堆区将会储存将会储存生命周期不确定，或者将生存到被程序显示删除的数据。例如C++语言中通过`new`语句创建的对象不随创建它的函数的退出而消亡，它将存在到对它进行显式的`delete`操作。这样的对象将会被储存在堆区。

#### 存储管理器

堆区的存储管理器主要应有两个基本功能：

1. 分配

    LVM提供申请对象的虚拟机指令，在执行这类指令时，存储管理器将会试图从堆的剩余空间中申请需要的内存。如果没有这些内存，它应向其宿主系统请求新的内存空间。如果还是请求失败，LVM将会传出内存耗尽的错误。

2. 回收

    LVM同时提供释放内存空间的虚拟机指令。这部分内存将会重新回到堆内存缓冲区中以待下一次使用。一般来说，LVM不会将这部分内存归还给宿主操作系统。